<html><head><title>OD</title><link
rel="stylesheet" type="text/css" href="common.css"><link
rel="stylesheet" type="text/css" href="blog.css"></head><body>
<header><div
id="name">
<a><span
id="optional">optional</span><span
id="dev">dev</span></a></div><div
id="links">
<a
href="https://github.com/optionaldev"><svg
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="26" height="26" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path
d="M12 0a12 12 0 1 0 0 24a12 12 0 0 0 0-24zm3.163 21.783h-.093a.513.513 0 0 1-.382-.14a.513.513 0 0 1-.14-.372v-1.406c.006-.467.01-.94.01-1.416a3.693 3.693 0 0 0-.151-1.028a1.832 1.832 0 0 0-.542-.875a8.014 8.014 0 0 0 2.038-.471a4.051 4.051 0 0 0 1.466-.964c.407-.427.71-.943.885-1.506a6.77 6.77 0 0 0 .3-2.13a4.138 4.138 0 0 0-.26-1.476a3.892 3.892 0 0 0-.795-1.284a2.81 2.81 0 0 0 .162-.582c.033-.2.05-.402.05-.604c0-.26-.03-.52-.09-.773a5.309 5.309 0 0 0-.221-.763a.293.293 0 0 0-.111-.02h-.11c-.23.002-.456.04-.674.111a5.34 5.34 0 0 0-.703.26a6.503 6.503 0 0 0-.661.343c-.215.127-.405.249-.573.362a9.578 9.578 0 0 0-5.143 0a13.507 13.507 0 0 0-.572-.362a6.022 6.022 0 0 0-.672-.342a4.516 4.516 0 0 0-.705-.261a2.203 2.203 0 0 0-.662-.111h-.11a.29.29 0 0 0-.11.02a5.844 5.844 0 0 0-.23.763c-.054.254-.08.513-.081.773c0 .202.017.404.051.604c.033.199.086.394.16.582A3.888 3.888 0 0 0 5.702 10a4.142 4.142 0 0 0-.263 1.476a6.871 6.871 0 0 0 .292 2.12c.181.563.483 1.08.884 1.516c.415.422.915.75 1.466.964c.653.25 1.337.41 2.033.476a1.828 1.828 0 0 0-.452.633a2.99 2.99 0 0 0-.2.744a2.754 2.754 0 0 1-1.175.27a1.788 1.788 0 0 1-1.065-.3a2.904 2.904 0 0 1-.752-.824a3.1 3.1 0 0 0-.292-.382a2.693 2.693 0 0 0-.372-.343a1.841 1.841 0 0 0-.432-.24a1.2 1.2 0 0 0-.481-.101c-.04.001-.08.005-.12.01a.649.649 0 0 0-.162.02a.408.408 0 0 0-.13.06a.116.116 0 0 0-.06.1a.33.33 0 0 0 .14.242c.093.074.17.131.232.171l.03.021c.133.103.261.214.382.333c.112.098.213.209.3.33c.09.119.168.246.231.381c.073.134.15.288.231.463c.188.474.522.875.954 1.145c.453.243.961.364 1.476.351c.174 0 .349-.01.522-.03c.172-.028.343-.057.515-.091v1.743a.5.5 0 0 1-.533.521h-.062a10.286 10.286 0 1 1 6.324 0v.005z"/><rect
x="0" y="0" width="24" height="24" fill="rgba(1, 0, 0, 0)" /></svg></a>
<a
href="https://instagram.com/optionaldev"><svg
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="26" height="26" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path
d="M8 0C5.829 0 5.556.01 4.703.048C3.85.088 3.269.222 2.76.42a3.917 3.917 0 0 0-1.417.923A3.927 3.927 0 0 0 .42 2.76C.222 3.268.087 3.85.048 4.7C.01 5.555 0 5.827 0 8.001c0 2.172.01 2.444.048 3.297c.04.852.174 1.433.372 1.942c.205.526.478.972.923 1.417c.444.445.89.719 1.416.923c.51.198 1.09.333 1.942.372C5.555 15.99 5.827 16 8 16s2.444-.01 3.298-.048c.851-.04 1.434-.174 1.943-.372a3.916 3.916 0 0 0 1.416-.923c.445-.445.718-.891.923-1.417c.197-.509.332-1.09.372-1.942C15.99 10.445 16 10.173 16 8s-.01-2.445-.048-3.299c-.04-.851-.175-1.433-.372-1.941a3.926 3.926 0 0 0-.923-1.417A3.911 3.911 0 0 0 13.24.42c-.51-.198-1.092-.333-1.943-.372C10.443.01 10.172 0 7.998 0h.003zm-.717 1.442h.718c2.136 0 2.389.007 3.232.046c.78.035 1.204.166 1.486.275c.373.145.64.319.92.599c.28.28.453.546.598.92c.11.281.24.705.275 1.485c.039.843.047 1.096.047 3.231s-.008 2.389-.047 3.232c-.035.78-.166 1.203-.275 1.485a2.47 2.47 0 0 1-.599.919c-.28.28-.546.453-.92.598c-.28.11-.704.24-1.485.276c-.843.038-1.096.047-3.232.047s-2.39-.009-3.233-.047c-.78-.036-1.203-.166-1.485-.276a2.478 2.478 0 0 1-.92-.598a2.48 2.48 0 0 1-.6-.92c-.109-.281-.24-.705-.275-1.485c-.038-.843-.046-1.096-.046-3.233c0-2.136.008-2.388.046-3.231c.036-.78.166-1.204.276-1.486c.145-.373.319-.64.599-.92c.28-.28.546-.453.92-.598c.282-.11.705-.24 1.485-.276c.738-.034 1.024-.044 2.515-.045v.002zm4.988 1.328a.96.96 0 1 0 0 1.92a.96.96 0 0 0 0-1.92zm-4.27 1.122a4.109 4.109 0 1 0 0 8.217a4.109 4.109 0 0 0 0-8.217zm0 1.441a2.667 2.667 0 1 1 0 5.334a2.667 2.667 0 0 1 0-5.334z"/><rect
x="0" y="0" width="16" height="16" fill="rgba(0, 0, 0, 0)" /></svg></a></div>
</header><div
id="main"><div
id="fun">import Blog</div><h1>UIViewRepresentable</h1><h2>Tested with Xcode 12.3</h2><p>With each passing year, we hope for more and more UI components to be added to SwiftUI, but even though the framework has been out since the 2019 edition of WWDC, there's still a few things that we miss&nbsp;dearly.</p><p>We'll look over UITextField, a component that I find myself bringing into SwiftUI projects over and over again. The default TextField offered doesn't have the ability to become or resign first responder. Deal&nbsp;breaker&nbsp;&#128581;</p><p>Luckily, Apple has provided a way to bring a UIKit component and integrate it seamlessly into our SwiftUI code, using the UIViewRepresentable protocol, so let's dive right&nbsp;in!</p><div
class="source originshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9</pre></div><div
class="code"><pre>
<span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> CustomTextField: <span class="builtinType">UIViewRepresentable</span> {
  <span class="keyword">func</span> <span class="method">makeUIView</span>(context: <span class="builtinType">Context</span>) -&gt; <span class="builtinType">UITextField</span> {
    <span class="keyword">return</span> <span class="builtinType">UITextField</span>()
  }
  
  <span class="keyword">func</span> <span class="method">updateUIView</span>(_ uiView: <span class="builtinType">UITextField</span>, context: <span class="builtinType">Context</span>) {}
}
</pre></div></div><p>When implementing the UIViewRepresentable protocol, we need to provide the implementation for 2 methods. The former manages the creation and setup of our UIKit component, while the latter deals with making sure the UIKit component stays up-to-date.</p><p>Throw in a <span>CustomTextField()</span> somewhere and start using your new shiny SwiftUI view!<br>
It isn't very useful right now since we're writing text into the void, so let's see how we can inform our counterpart of the changes.<div
class="source originshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></div><div
class="code"><pre>
<span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> CustomTextField: <span class="builtinType">UIViewRepresentable</span> {
  @<span class="builtinType">Binding</span> <span class="keyword">var</span> text: <span class="builtinType">String</span>
  
  <span class="keyword">func</span> <span class="method">makeUIView</span>(context: Context) -&gt; <span class="builtinType">UITextField</span> {
    <span class="keyword">let</span> textField = <span class="builtinType">UITextField</span>()
    <span class="builtinType">NotificationCenter</span>.<span class="otherBuiltin">default</span>.<span class="otherBuiltin">addObserver</span>(forName: <span class="builtinType">UITextField</span>.<span class="otherBuiltin">textDidChangeNotification</span>,
                                           object: <span class="keyword">nil</span>,
                                           queue: .<span class="otherBuiltin">main</span>) { _ <span class="keyword">in</span>
      text = textField.<span class="otherBuiltin">text</span> ?? <span class="constant">""</span>
    }
    <span class="keyword">return</span> textField
  }
  
  <span class="keyword">func</span> <span class="method">updateUIView</span>(_ uiView: <span class="builtinType">UITextField</span>, context: Context) {}
}</pre></div></div><p>The text binding will hold a reference to a value that was passed to our CustomTextField during initialization. Remember that since this is a struct, an init method is automatically generated.<p>To monitor our changes, there's 2 approaches we can take. The first one involves adding a modifier to our view and listening to changes:</p><div
class="source usageshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13</pre></div><div
class="code"><pre>
<span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="builtinType">View</span> {
  @<span class="builtinType">State</span> <span class="keyword">private</span> <span class="keyword">var</span> text: <span class="builtinType">String</span> = <span class="constant">""</span>
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="builtinType">View</span> {
    CustomTextField(text: <span class="operator">$</span>text)
      .<span class="otherBuiltin">onChange</span>(of: text) { _ <span class="keyword">in</span>
        <span class="otherBuiltin">print</span>(text)
      }
    }
  }
}</pre></div></div><p>The second approach involves a view model that holds our text variable:</p><div
class="source usageshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div><div
class="code"><pre>
<span class="keyword">import</span> SwiftUI

<span class="keyword">final</span> <span class="keyword">class</span> ViewModel: <span class="builtinType">ObservableObject</span> {
  <span class="keyword">init</span>() {}
  
  @<span class="builtinType">Published</span> <span class="keyword">var</span> text = <span class="constant">""</span> {
    <span class="keyword">didSet</span> {
      <span class="otherBuiltin">print</span>(text)
    }
  }
}

<span class="keyword">struct</span> ContentView: <span class="builtinType">View</span> {
  @<span class="builtinType">ObservedObject</span> <span class="keyword">private</span> <span class="keyword">var</span> viewModel = ViewModel()
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="builtinType">View</span> {
    <span class="builtinType">VStack</span> {
      CustomTextField(text: <span class="operator">$</span>viewModel.<span class="otherBuiltin">text</span>)
    }
  }
}</pre></div></div><p>Couldn't we have used didSet in the first example? We could, but we would only get some of the updates. Because of how <span>struct</span> works in tandem with <span>@State</span>, didSet isn't aware of changes that are propagated by bindings. The only time didSet would trigger is when we would change the text variable from inside some methods like onAppear, onChange, etc.</p><p>So far, we've looked over keeping the SwiftUI component up-to-date. But what about keeping the UIKit component up-to-date? Let's say we would like to have our text field text reset when the user types "ABC".</p><div
class="source usageshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></div><div
class="code"><pre>
<span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="builtinType">View</span> {
  @<span class="builtinType">State</span> <span class="keyword">private</span> <span class="keyword">var</span> text = <span class="constant">""</span>
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="builtinType">View</span> {
    <span class="builtinType">VStack</span> {
      CustomTextField(text: <span class="operator">$</span>text)
        .<span class="otherBuiltin">onChange</span>(of: text) { _ <span class="keyword">in</span>
          <span class="keyword">if</span> text == "ABC" {
            text = <span class="constant">""</span>
          }
        }
    }
  }
}
</pre></div></div><p>If we try to run it as it is right now, we would notice that even though we modify the text variable, it's not reflected on screen. This is where the <span>updateUIView</span> method comes into play. We just need to make one simple change:<div
class="source originshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3</pre></div><div
class="code"><pre>
<span class="keyword">func</span> <span class="method">updateUIView</span>(_ uiView: <span class="builtinType">UITextField</span>, context: <span class="builtinType">Context</span>) {
  uiView.<span class="otherBuiltin">text</span> = text
}</pre></div></div><p>So far so good. Now in order to make our CustomTextField capable of become and resigning first responder, the simplest approach would be to have another binding in our custom view, like so:</p><div
class="source originshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div><div
class="code"><pre>
<span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> CustomTextField: <span class="builtinType">UIViewRepresentable</span> {
  
  @<span class="builtinType">Binding</span> <span class="keyword">var</span> text: <span class="builtinType">String</span>
  @<span class="builtinType">Binding</span> <span class="keyword">var</span> firstResponder: <span class="builtinType">Bool</span>

  <span class="keyword">let</span> textField = <span class="builtinType">UITextField</span>()
  
  <span class="keyword">func</span> <span class="method">makeUIView</span>(context: <span class="builtinType">Context</span>) -&gt; <span class="builtinType">UITextField</span> {
    <span class="builtinType">NotificationCenter</span>.<span class="otherBuiltin">default</span>.<span class="otherBuiltin">addObserver</span>(forName: <span class="builtinType">UITextField</span>.<span class="otherBuiltin">textDidChangeNotification</span>,
                                           object: <span class="keyword">nil</span>,
                                           queue: .<span class="otherBuiltin">main</span>) { _ <span class="keyword">in</span>
      text = textField.<span class="otherBuiltin">text</span> <span class="operator">??</span> <span class="constant">""</span>
    }
    <span class="keyword">return</span> textField
  }

  <span class="keyword">func</span> <span class="method">updateUIView</span>(_ uiView: <span class="builtinType">UITextField</span>, context: <span class="builtinType">Context</span>) {
    uiView.<span class="otherBuiltin">text</span> = text
    <span class="keyword">if</span> firstResponder <span class="operator">&&</span> <span class="exclamation">!</span>textField.<span class="otherBuiltin">isFirstResponder</span> {
      textField.<span class="otherBuiltin">becomeFirstResponder</span>()
    } <span class="keyword">else</span> <span class="keyword">if</span> <span class="exclamation">!</span>firstResponder <span class="operator">&&</span> textField.<span class="otherBuiltin">isFirstResponder</span> {
      textField.<span class="otherBuiltin">resignFirstResponder</span>()
    }
  }
}</pre></div></div><p>Now everytime the value of firstResponder changes, the keyboard will appear or disappear based on the value. Another change you might have noticed is adding the UITextField as a property. This is necessary in order to have a reference to it that we can use to call the responder methods on.</p><p>What if we wanted to use the delegate approach instead of the NotificationCenter approach? Then, there is one more concept we need to go over, which is <span>Coordinator</span>.</p><p>Some ready to use code:</p></div>
<footer>
Copyright &copy; optionaldev 2021. All rights reserved.
</footer></body></html>
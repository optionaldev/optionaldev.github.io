<html><head><title>OD</title><link
rel="stylesheet" type="text/css" href="common.css"><link
rel="stylesheet" type="text/css" href="blog.css"><link
rel="icon" type="image/x-icon" href="favicon.ico"></head><body>
<header><div
id="name"><div
id="optional">optional</div><div
id="dev">dev</div></div><div
id="links">
<a
href="https://github.com/optionaldev"><svg
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="26" height="26" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path
d="M12 0a12 12 0 1 0 0 24a12 12 0 0 0 0-24zm3.163 21.783h-.093a.513.513 0 0 1-.382-.14a.513.513 0 0 1-.14-.372v-1.406c.006-.467.01-.94.01-1.416a3.693 3.693 0 0 0-.151-1.028a1.832 1.832 0 0 0-.542-.875a8.014 8.014 0 0 0 2.038-.471a4.051 4.051 0 0 0 1.466-.964c.407-.427.71-.943.885-1.506a6.77 6.77 0 0 0 .3-2.13a4.138 4.138 0 0 0-.26-1.476a3.892 3.892 0 0 0-.795-1.284a2.81 2.81 0 0 0 .162-.582c.033-.2.05-.402.05-.604c0-.26-.03-.52-.09-.773a5.309 5.309 0 0 0-.221-.763a.293.293 0 0 0-.111-.02h-.11c-.23.002-.456.04-.674.111a5.34 5.34 0 0 0-.703.26a6.503 6.503 0 0 0-.661.343c-.215.127-.405.249-.573.362a9.578 9.578 0 0 0-5.143 0a13.507 13.507 0 0 0-.572-.362a6.022 6.022 0 0 0-.672-.342a4.516 4.516 0 0 0-.705-.261a2.203 2.203 0 0 0-.662-.111h-.11a.29.29 0 0 0-.11.02a5.844 5.844 0 0 0-.23.763c-.054.254-.08.513-.081.773c0 .202.017.404.051.604c.033.199.086.394.16.582A3.888 3.888 0 0 0 5.702 10a4.142 4.142 0 0 0-.263 1.476a6.871 6.871 0 0 0 .292 2.12c.181.563.483 1.08.884 1.516c.415.422.915.75 1.466.964c.653.25 1.337.41 2.033.476a1.828 1.828 0 0 0-.452.633a2.99 2.99 0 0 0-.2.744a2.754 2.754 0 0 1-1.175.27a1.788 1.788 0 0 1-1.065-.3a2.904 2.904 0 0 1-.752-.824a3.1 3.1 0 0 0-.292-.382a2.693 2.693 0 0 0-.372-.343a1.841 1.841 0 0 0-.432-.24a1.2 1.2 0 0 0-.481-.101c-.04.001-.08.005-.12.01a.649.649 0 0 0-.162.02a.408.408 0 0 0-.13.06a.116.116 0 0 0-.06.1a.33.33 0 0 0 .14.242c.093.074.17.131.232.171l.03.021c.133.103.261.214.382.333c.112.098.213.209.3.33c.09.119.168.246.231.381c.073.134.15.288.231.463c.188.474.522.875.954 1.145c.453.243.961.364 1.476.351c.174 0 .349-.01.522-.03c.172-.028.343-.057.515-.091v1.743a.5.5 0 0 1-.533.521h-.062a10.286 10.286 0 1 1 6.324 0v.005z"/><rect
x="0" y="0" width="24" height="24" fill="rgba(1, 0, 0, 0)" /></svg></a>
<a
href="https://instagram.com/optionaldev"><svg
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="26" height="26" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path
d="M8 0C5.829 0 5.556.01 4.703.048C3.85.088 3.269.222 2.76.42a3.917 3.917 0 0 0-1.417.923A3.927 3.927 0 0 0 .42 2.76C.222 3.268.087 3.85.048 4.7C.01 5.555 0 5.827 0 8.001c0 2.172.01 2.444.048 3.297c.04.852.174 1.433.372 1.942c.205.526.478.972.923 1.417c.444.445.89.719 1.416.923c.51.198 1.09.333 1.942.372C5.555 15.99 5.827 16 8 16s2.444-.01 3.298-.048c.851-.04 1.434-.174 1.943-.372a3.916 3.916 0 0 0 1.416-.923c.445-.445.718-.891.923-1.417c.197-.509.332-1.09.372-1.942C15.99 10.445 16 10.173 16 8s-.01-2.445-.048-3.299c-.04-.851-.175-1.433-.372-1.941a3.926 3.926 0 0 0-.923-1.417A3.911 3.911 0 0 0 13.24.42c-.51-.198-1.092-.333-1.943-.372C10.443.01 10.172 0 7.998 0h.003zm-.717 1.442h.718c2.136 0 2.389.007 3.232.046c.78.035 1.204.166 1.486.275c.373.145.64.319.92.599c.28.28.453.546.598.92c.11.281.24.705.275 1.485c.039.843.047 1.096.047 3.231s-.008 2.389-.047 3.232c-.035.78-.166 1.203-.275 1.485a2.47 2.47 0 0 1-.599.919c-.28.28-.546.453-.92.598c-.28.11-.704.24-1.485.276c-.843.038-1.096.047-3.232.047s-2.39-.009-3.233-.047c-.78-.036-1.203-.166-1.485-.276a2.478 2.478 0 0 1-.92-.598a2.48 2.48 0 0 1-.6-.92c-.109-.281-.24-.705-.275-1.485c-.038-.843-.046-1.096-.046-3.233c0-2.136.008-2.388.046-3.231c.036-.78.166-1.204.276-1.486c.145-.373.319-.64.599-.92c.28-.28.546-.453.92-.598c.282-.11.705-.24 1.485-.276c.738-.034 1.024-.044 2.515-.045v.002zm4.988 1.328a.96.96 0 1 0 0 1.92a.96.96 0 0 0 0-1.92zm-4.27 1.122a4.109 4.109 0 1 0 0 8.217a4.109 4.109 0 0 0 0-8.217zm0 1.441a2.667 2.667 0 1 1 0 5.334a2.667 2.667 0 0 1 0-5.334z"/><rect
x="0" y="0" width="16" height="16" fill="rgba(0, 0, 0, 0)" /></svg></a></div>
</header><div
id="main"><div
id="fun">import Blog</div><h1>UIViewRepresentable</h1><h2>Tested with Xcode 12.3</h2><p>With each passing year, we hope for more and more UI components to be added to SwiftUI, but even though the framework has been out since the 2019 edition of WWDC, there's still a few things that we miss&nbsp;dearly.</p><p>We'll look over UITextField, a component that I find myself bringing into SwiftUI projects over and over again. The default TextField offered doesn't have the ability to become or resign first responder. Deal&nbsp;breaker&nbsp;&#128581;</p><p>Luckily, Apple has provided a way to bring a UIKit component and integrate it seamlessly into our SwiftUI code, using the UIViewRepresentable protocol, so let's dive right&nbsp;in!</p><div
class="source originshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9</pre></div><div
class="code"><pre>
<a>import</a> SwiftUI

<a>struct</a> CustomTextField: <b>UIViewRepresentable</b> {
  <a>func</a> <s>makeUIView</s>(context: <b>Context</b>) -&gt; <b>UITextField</b> {
    <a>return</a> <b>UITextField</b>()
  }
  
  <a>func</a> <s>updateUIView</s>(_ textField: <b>UITextField</b>, context: <b>Context</b>) {}
}
</pre></div></div><p>When implementing the UIViewRepresentable protocol, we need to provide the implementation for 2&nbsp;methods. The former manages the creation and setup of our UIKit component, while the latter deals with making sure the UIKit component stays up-to-date.</p><p>Add the following code somewhere and start using your new shiny SwiftUI&nbsp;view!</p><div
class="source usageshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9</pre></div><div
class="code"><pre>
<a>import</a> SwiftUI

<a>struct</a> ContentView: <b>View</b> {
  <a>var</a> body: <a>some</a> <b>View</b> {
    CustomTextField()
      .<i>frame</i>(width: <q>150</q>, height: <q>30</q>)
      .<i>background</i>(<b>Color</b>.<i>gray</i>)
  }
}</pre></div></div><p>It isn't very useful right now since we're writing text into the void, so let's see how we can inform the ContentView of our&nbsp;changes.<div
class="source originshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div><div
class="code"><pre>
<a>import</a> SwiftUI

<a>struct</a> CustomTextField: <b>UIViewRepresentable</b> {
  @<b>Binding</b> <a>var</a> text: <b>String</b>
  
  <a>func</a> <s>makeUIView</s>(context: <b>Context</b>) -&gt; <b>UITextField</b> {
    <a>let</a> textField = <b>UITextField</b>()
    <b>NotificationCenter</b>.<i>default</i>.<i>addObserver</i>(forName: <b>UITextField</b>.<i>textDidChangeNotification</i>,
                                           object: <a>nil</a>,
                                           queue: .<i>main</i>) { _ <a>in</a>
      text = textField.<i>text</i> <u>??</u> <q>""</q>
    }
    <a>return</a> textField
  }
  
  <a>func</a> <s>updateUIView</s>(_ textField: <b>UITextField</b>, context: <b>Context</b>) {}
  
  <a>static</a> <a>func</a> <s>dismantleUIView</s>(_ textField: <b>UITextField</b>, coordinator: <b>Coordinator</b>) {
    <b>NotificationCenter</b>.<i>default</i>.<i>removeObserver</i>(<a>self</a>)
  }
}</pre></div></div><p>The text binding will hold a reference to a value that was passed to our CustomTextField during initialization. Remember that since this is a struct, an init method is automatically&nbsp;generated.<p>Because we're adding our custom view as an observer, we also need to make sure that we perform the necessary clean-up. UIViewRepresentable protocol also supplies dismantleUIView for this purpose, which acts like a&nbsp;<span>deinit</span>.</p><p>To monitor our changes, there's 2 approaches we can take. The first one involves adding a modifier to our view and listening to&nbsp;changes:</p><div
class="source usageshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></div><div
class="code"><pre>
<a>import</a> SwiftUI

<a>struct</a> ContentView: <b>View</b> {
  @<b>State</b> <a>private</a> <a>var</a> text: <b>String</b> = <q>""</q>
  
  <a>var</a> body: <a>some</a> <b>View</b> {
    CustomTextField(text: <u>$</u>text)
      .<i>frame</i>(width: <q>150</q>, height: <q>30</q>)
      .<i>background</i>(<b>Color</b>.<i>gray</i>)
      .<i>onChange</i>(of: text) { _ <a>in</a>
        <i>print</i>(<q>"onChange text = <a>\(text)</a>"</q>)
      }
  }
}
</pre></div></div><p>The second approach involves a view model that holds our text&nbsp;variable:</p><div
class="source usageshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div><div
class="code"><pre>
<a>import</a> SwiftUI

<a>final</a> <a>class</a> ViewModel: <b>ObservableObject</b> {
  <a>init</a>() {}
  
  @<b>Published</b> <a>var</a> text = <q>""</q> {
    <a>didSet</a> {
      <i>print</i>(<q>"didSet text = <a>\(text)</a>"</q>)
    }
  }
}

<a>struct</a> ContentView: <b>View</b> {
  @<b>ObservedObject</b> <a>private</a> <a>var</a> viewModel = ViewModel()
  
  <a>var</a> body: <a>some</a> <b>View</b> {
    CustomTextField(text: <u>$</u>viewModel.<i>text</i>)
      .<i>frame</i>(width: <q>150</q>, height: <q>30</q>)
      .<i>background</i>(<b>Color</b>.<i>gray</i>)
  }
}
</pre></div></div><p>In both example you may have noticed the <u>$</u> sign. This is used to create a <span>Binding</span> for that value. It is similar to the idea of creating a pointer in other languages.</p><p>Couldn't we have used didSet in the first example? We could, but we would only get some of the updates. Because of how <span>struct</span> works in tandem with <span>@State</span>, didSet isn't aware of changes that are propagated by bindings. The only time didSet would trigger is when we would change the text variable from inside some methods like onAppear, onChange,&nbsp;etc.</p><p>So far, we've looked over keeping the SwiftUI component up-to-date. But what about keeping the UIKit component up-to-date? Let's say we would like to have our text field text reset when the user types&nbsp;"ABC".</p><div
class="source usageshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></div><div
class="code"><pre>
<a>import</a> SwiftUI

<a>struct</a> ContentView: <b>View</b> {
  @<b>State</b> <a>private</a> <a>var</a> text = <q>""</q>
  
  <a>var</a> body: <a>some</a> <b>View</b> {
    CustomTextField(text: <u>$</u>text)
      .<i>frame</i>(width: <q>150</q>, height: <q>30</q>)
      .<i>background</i>(<b>Color</b>.<i>gray</i>)
      .<i>onChange</i>(of: text) { _ <a>in</a>
        <a>if</a> text <u>==</u> <q>"ABC"</q> {
          text = <q>""</q>
        }
      }
  }
}
</pre></div></div><p>If we try to run it as it is right now, we would notice that even though we type "ABC" and it should reset, that's not what happens. This is where the <span>updateUIView</span> method comes into play. We just need to make one simple change to our custom&nbsp;view:</p><div
class="source originshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3</pre></div><div
class="code"><pre>
<a>func</a> <s>updateUIView</s>(_ textField: <b>UITextField</b>, context: <b>Context</b>) {
  textField.<i>text</i> = text
}
</pre></div></div><p>We've successfully created the two way communication! If we type "AB", once the "C" is entered, the text will&nbsp;disappear.</p><p>So far so good. Next on the list, making our CustomTextField capable of become and resigning first responder. The simplest approach would be to have another binding in our custom view, like&nbsp;so:</p><div
class="source originshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div><div
class="code"><pre>
<a>import</a> SwiftUI

<a>struct</a> CustomTextField: <b>UIViewRepresentable</b> {
  
  @<b>Binding</b> <a>var</a> text: <b>String</b>
  @<b>Binding</b> <a>var</a> firstResponder: <b>Bool</b>
  
  <a>func</a> <s>makeUIView</s>(context: <b>Context</b>) -&gt; <b>UITextField</b> {
    <a>let</a> textField = <b>UITextField</b>()
    <b>NotificationCenter</b>.<i>default</i>.<i>addObserver</i>(forName: <b>UITextField</b>.<i>textDidChangeNotification</i>,
                                           object: <a>nil</a>,
                                           queue: .<i>main</i>) { _ <a>in</a>
      text = textField.<i>text</i> <u>??</u> <q>""</q>
    }
    <a>return</a> textField
  }
  
  <a>func</a> <s>updateUIView</s>(_ textField: <b>UITextField</b>, context: <b>Context</b>) {
    textField.<i>text</i> = text
    <a>if</a> firstResponder <u>&&</u> <p>!</p>textField.<i>isFirstResponder</i> {
      textField.<i>becomeFirstResponder</i>()
    } <a>else</a> <a>if</a> <p>!</p>firstResponder <u>&&</u> textField.<i>isFirstResponder</i> {
      textField.<i>resignFirstResponder</i>()
    }
  }
}</pre></div></div><p>Now everytime the value of firstResponder changes, the keyboard will appear / disappear based on the value. Create another State variable, this time a boolean. Give it the initial value of true and pass it on to the initializer that is giving the compile&nbsp;error.</p><p>What if we wanted to use the delegate approach instead of the NotificationCenter approach? In an ideal world, we would simply make our custom type conform to UITextFieldDelegate, but doing so requires our type to also conform to NSObjectProtocol, which only classes can&nbsp;do.</p><p>This where the concept of <span>Coordinator</span> comes into&nbsp;play:</p><div
class="source originshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div><div
class="code"><pre>
<a>import</a> SwiftUI

<a>struct</a> CustomTextField: <b>UIViewRepresentable</b> {
  @<b>Binding</b> <a>var</a> text: <b>String</b>
  @<b>Binding</b> <a>var</a> firstResponder: <b>Bool</b>

  <a>func</a> <s>makeUIView</s>(context: <b>Context</b>) -&gt; <b>UITextField</b> {
    <a>let</a> textField = <b>UITextField</b>()
    textField.<i>delegate</i> = context.<i>coordinator</i>
    <a>return</a> textField
  }

  <a>func</a> <s>updateUIView</s>(_ textField: <b>UITextField</b>, context: <b>Context</b>) {
    textField.<i>text</i> = text
    <a>if</a> firstResponder <u>&&</u> <p>!</p>textField.<i>isFirstResponder</i> {
      textField.<i>becomeFirstResponder</i>()
    } <a>else</a> <a>if</a> <p>!</p>firstResponder <u>&&</u> textField.<i>isFirstResponder</i> {
      textField.<i>resignFirstResponder</i>()
    }
  }
  
  <a>func</a> <s>makeCoordinator</s>() -&gt; <b>Coordinator</b> {
    <a>return</a> <b>Coordinator</b>(text: <u>$</u>text)
  }
  
  <a>final</a> <a>class</a> <b>Coordinator</b>: <b>NSObject</b>, <b>UITextFieldDelegate</b> {
    @<b>Binding</b> <a>var</a> text: <b>String</b>
    
    <a>init</a>(text: <b>Binding</b>&lt;<b>String</b>&gt;) {
      <u>_</u>text = text
    }
    
    <a>func</a> <s>textField</s>(_ textField: <b>UITextField</b>,
                   shouldChangeCharactersIn range: <b>NSRange</b>,
                   replacementString string: <b>String</b>) -&gt; <b>Bool</b> {
      text = <b>NSString</b>(string: textField.<i>text</i> <u>??</u> <q>""</q>)
        .<i>replacingCharacters</i>(in: range, with: string)
      <a>return</a> <a>true</a>
    }
  }
}
</pre></div></div><p>The Coordinator is a class and therefore can conform to UITextFieldDelegate. It has the same binding as the parent struct. To reference that binding in the init method, the <span><u>_</u></span> prefix is used.</p><p>Is it done? It's done!</p><p>As a final note, even though some SwiftUI modifiers work with UIViewRepresentable views, like <span>.frame(...)</span>, <span>.background(...)</span>, <span>.padding(...)</span>, more internal ones such as <span>.font(...)</span>, <span>.foregroundColor</span> might not. My usual setup for UITextField is something&nbsp;like:</p><div
class="source usageshadow"><div
class="line" onselectstart="return false"><pre>
1
2
3
4</pre></div><div
class="code"><pre>
  textField.<i>autocapitalizationType</i> = .<i>none</i>
  textField.<i>font</i> = .<i>systemFont</i>(ofSize: <q>20</q>)
  textField.<i>textAlignment</i> = .<i>center</i>
  textField.<i>textColor</i> = .<i>blue</i>
</pre></div></div><p>Thank you for taking the time to read and all the best on your SwiftUI journey!<br><br><br><br></p>
<footer>
Copyright &copy; optionaldev 2021. All rights reserved.
</footer></body></html>
<!--Minify by http://www.MinifyWeb.com/-->